/**
 * DAO Proposal Management
 * 
 * This module handles creating and managing trading proposals for the DAO.
 * Implements Builder DAO governor proposal pattern (adapted from Gnars DAO).
 * 
 * Flow:
 * 1. AI agent selects a coin to buy
 * 2. createBuyCoinProposal() uses Zora SDK to generate trade transaction
 * 3. Builds proposal with targets[], values[], calldatas[], description
 * 4. Ready to submit to Builder DAO governor via propose()
 * 
 * References:
 * - Gnars website: github.com/r4topunk/gnars-website
 * - Builder DAO: docs.zora.co/contracts/governor
 */

import { createTradeCall, setApiKey, type TradeParameters } from '@zoralabs/coins-sdk';
import { parseEther, encodeFunctionData, type Address, type Hex } from 'viem';
import { CdpClient } from '@coinbase/cdp-sdk';

// ============================================
// Types
// ============================================

export type ProposalStatus = 'pending' | 'approved' | 'rejected' | 'executed';

export type TriggerSource = 'agent' | 'manual' | 'scheduled';

/**
 * Builder DAO Governor proposal structure
 * Mirrors the propose() function parameters:
 * propose(address[] targets, uint256[] values, bytes[] calldatas, string description)
 */
export type GovernorProposal = {
  targets: Address[];      // Contract addresses to call
  values: bigint[];        // ETH amounts to send (in wei)
  calldatas: Hex[];        // Encoded function calls
  description: string;     // Markdown proposal description
};

/**
 * Buy coin proposal with Governor data
 */
export type BuyCoinProposal = {
  proposalId: string;
  coinAddress: Address;
  coinSymbol: string | null;
  coinName: string | null;
  ethAmount: string; // Human-readable ETH amount (e.g., "0.1")
  slippagePercent: number; // e.g., 5 for 5%
  suggestedReason: string;
  triggerSource: TriggerSource;
  status: ProposalStatus;
  createdAt: string;
  executedAt?: string | null;
  txHash?: string | null;
  // Governor proposal data (ready for on-chain submission)
  governorProposal: GovernorProposal;
};

// ============================================
// In-Memory Storage (MVP)
// ============================================
// In a production system, this would be stored in a database

const proposals: Map<string, BuyCoinProposal> = new Map();

// ============================================
// Configuration
// ============================================

/**
 * Get required environment variables
 * Validates that all required variables are set
 */
function getConfig() {
  const DAO_TREASURY_ADDRESS = process.env.DAO_TREASURY_ADDRESS;
  const ZORA_API_KEY = process.env.ZORA_API_KEY;

  if (!DAO_TREASURY_ADDRESS) {
    throw new Error('DAO_TREASURY_ADDRESS must be set in .env.local');
  }

  if (!ZORA_API_KEY) {
    throw new Error('ZORA_API_KEY must be set in .env.local');
  }

  return {
    DAO_TREASURY_ADDRESS: DAO_TREASURY_ADDRESS as Address,
    ZORA_API_KEY,
  };
}

// ============================================
// Helper Functions
// ============================================

/**
 * Generate a unique proposal ID
 */
function generateProposalId(): string {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 9);
  return `proposal_${timestamp}_${random}`;
}

/**
 * Build proposal description string (Markdown format)
 */
function buildProposalDescription({
  coinAddress,
  coinSymbol,
  coinName,
  ethAmount,
  slippagePercent,
  suggestedReason,
  triggerSource,
  daoTreasuryAddress,
}: {
  coinAddress: Address;
  coinSymbol: string | null;
  coinName: string | null;
  ethAmount: string;
  slippagePercent: number;
  suggestedReason: string;
  triggerSource: TriggerSource;
  daoTreasuryAddress: Address;
}): string {
  const coinDisplayName = coinName || coinSymbol || coinAddress.slice(0, 10) + '...';
  const title = `Buy ${coinDisplayName} Creator Coin`;
  
  // Separate title and description with && delimiter
  const description = `SUMMARY
Purchase ${ethAmount} ETH worth of ${coinDisplayName} creator coin via Zora marketplace.

COIN DETAILS
Address: ${coinAddress}
Symbol: ${coinSymbol || 'N/A'}
Name: ${coinName || 'N/A'}

TRADE PARAMETERS
ETH Amount: ${ethAmount} ETH
Max Slippage: ${slippagePercent}%
Sender: DAO Treasury (${daoTreasuryAddress})
Recipient: DAO Treasury (coins return to DAO)

RATIONALE
${suggestedReason}

SOURCE
This proposal was generated by: ${triggerSource}

TRANSACTION DETAILS
This proposal will execute a swap through the Uniswap v4 router with Zora creator coin hooks. The transaction is generated using the Zora Coins SDK's createTradeCall() function.

---
Generated by AI Treasurer Agent`;

  return `${title} && ${description}`;
}

// ============================================
// Main Exports
// ============================================

/**
 * Create a new buy coin proposal with Governor transaction data
 * 
 * This function:
 * 1. Uses Zora SDK's createTradeCall() to generate swap transaction
 * 2. Builds Governor proposal structure (targets, values, calldatas)
 * 3. Stores proposal in memory (MVP)
 * 4. Returns complete proposal ready for on-chain submission
 * 
 * @param coinAddress - ERC-20 contract address of the creator coin
 * @param coinSymbol - Coin symbol (optional, for display)
 * @param coinName - Coin name (optional, for display)
 * @param ethAmount - Amount of ETH to spend (e.g., "0.1")
 * @param slippagePercent - Max slippage percentage (e.g., 5 for 5%)
 * @param suggestedReason - AI-generated reason for the purchase
 * @param triggerSource - Source that triggered the proposal
 * @returns The created proposal with Governor data
 * 
 * @example
 * ```typescript
 * const proposal = await createBuyCoinProposal({
 *   coinAddress: '0x123...',
 *   coinSymbol: 'VITALIK',
 *   coinName: 'Vitalik Buterin',
 *   ethAmount: '0.1',
 *   slippagePercent: 5,
 *   suggestedReason: 'Strong market momentum and high trading volume',
 *   triggerSource: 'agent',
 * });
 * 
 * // Submit to Governor (future implementation)
 * // await governor.propose(
 * //   proposal.governorProposal.targets,
 * //   proposal.governorProposal.values,
 * //   proposal.governorProposal.calldatas,
 * //   proposal.governorProposal.description
 * // );
 * ```
 */
export async function createBuyCoinProposal({
  coinAddress,
  coinSymbol,
  coinName,
  ethAmount,
  slippagePercent = 5,
  suggestedReason,
  triggerSource,
}: {
  coinAddress: Address;
  coinSymbol: string | null;
  coinName: string | null;
  ethAmount: string;
  slippagePercent?: number;
  suggestedReason: string;
  triggerSource: TriggerSource;
}): Promise<BuyCoinProposal> {
  // Get configuration and initialize SDK
  const config = getConfig();
  setApiKey(config.ZORA_API_KEY);
  
  const proposalId = generateProposalId();
  
  console.log(`üìù Creating proposal ${proposalId} for coin ${coinAddress}`);
  console.log(`   ETH Amount: ${ethAmount}, Slippage: ${slippagePercent}%`);

  // Step 1: Generate trade transaction using Zora SDK
  // This follows the exact pattern from Gnars:
  // const quote = await createTradeCall({ ... })
  const tradeParameters: TradeParameters = {
    sell: {
      type: 'eth', // Selling ETH
    },
    buy: {
      type: 'erc20', // Buying ERC-20 creator coin
      address: coinAddress,
    },
    amountIn: parseEther(ethAmount), // Convert ETH string to wei
    slippage: slippagePercent / 100, // Convert percentage to decimal (5% -> 0.05)
    sender: config.DAO_TREASURY_ADDRESS, // DAO treasury as sender
    recipient: config.DAO_TREASURY_ADDRESS, // Coins return to DAO treasury
  };

  console.log(`   Generating trade call via Zora SDK...`);
  
  let tradeCall;
  try {
    const quote = await createTradeCall(tradeParameters);
    
    if (!quote?.call) {
      throw new Error('Zora SDK returned invalid trade call');
    }
    
    tradeCall = quote.call;
    console.log(`   ‚úÖ Trade call generated successfully`);
    console.log(`   Target: ${tradeCall.target}`);
    console.log(`   Value: ${tradeCall.value.toString()} wei`);
    console.log(`   Calldata length: ${tradeCall.data.length} bytes`);
  } catch (error) {
    console.error(`   ‚ùå Failed to generate trade call:`, error);
    throw new Error(
      `Failed to generate trade call for ${coinAddress}: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }

  // Step 2: Build Governor proposal structure
  // The governor's propose() function expects:
  // - targets: address[] - Contract addresses to call
  // - values: uint256[] - ETH amounts to send (in wei)
  // - calldatas: bytes[] - Encoded function calls
  // - description: string - Markdown proposal description
  
  const targets: Address[] = [tradeCall.target as Address];
  const values: bigint[] = [BigInt(tradeCall.value)];
  const calldatas: Hex[] = [tradeCall.data as Hex];
  const description = buildProposalDescription({
    coinAddress,
    coinSymbol,
    coinName,
    ethAmount,
    slippagePercent,
    suggestedReason,
    triggerSource,
    daoTreasuryAddress: config.DAO_TREASURY_ADDRESS,
  });

  const governorProposal: GovernorProposal = {
    targets,
    values,
    calldatas,
    description,
  };

  // Step 3: Create and store proposal
  const proposal: BuyCoinProposal = {
    proposalId,
    coinAddress,
    coinSymbol,
    coinName,
    ethAmount,
    slippagePercent,
    suggestedReason,
    triggerSource,
    status: 'pending',
    createdAt: new Date().toISOString(),
    executedAt: null,
    txHash: null,
    governorProposal,
  };

  proposals.set(proposalId, proposal);

  console.log(`üìù ‚úÖ Created proposal ${proposalId}`);
  console.log(`   Status: ${proposal.status}`);
  console.log(`   Ready for Governor submission: targets.length=${targets.length}`);

  return proposal;
}

/**
 * Get a proposal by ID
 */
export function getProposal(proposalId: string): BuyCoinProposal | undefined {
  return proposals.get(proposalId);
}

/**
 * Get all proposals
 */
export function getAllProposals(): BuyCoinProposal[] {
  return Array.from(proposals.values());
}

/**
 * Update proposal status
 */
export function updateProposalStatus(
  proposalId: string,
  status: ProposalStatus,
  txHash?: string
): BuyCoinProposal | undefined {
  const proposal = proposals.get(proposalId);
  
  if (!proposal) {
    return undefined;
  }

  proposal.status = status;
  
  if (status === 'executed') {
    proposal.executedAt = new Date().toISOString();
    if (txHash) {
      proposal.txHash = txHash;
    }
  }

  proposals.set(proposalId, proposal);
  
  return proposal;
}

/**
 * Get proposals by status
 */
export function getProposalsByStatus(status: ProposalStatus): BuyCoinProposal[] {
  return Array.from(proposals.values()).filter(p => p.status === status);
}

/**
 * Get proposals by trigger source
 */
export function getProposalsBySource(source: TriggerSource): BuyCoinProposal[] {
  return Array.from(proposals.values()).filter(p => p.triggerSource === source);
}

// ============================================
// On-Chain Submission
// ============================================

/**
 * Governor proposal call structure
 * Compatible with Builder DAO / Nouns-style governors
 */
export type GovernorProposalCall = {
  targets: string[];      // Contract addresses to call
  values: string[];       // ETH amounts in wei (as strings)
  calldatas: string[];    // Hex-encoded function calls
  description: string;    // Markdown proposal description
};

/**
 * Result of submitting a proposal on-chain
 */
export type SubmitProposalResult = {
  txHash: string;         // Transaction hash of the propose() call
  proposalId?: string;    // On-chain proposal ID (if parsed from receipt)
};

/**
 * Minimal Builder/Nouns Governor ABI
 * Only includes the propose() function needed for creating proposals
 */
const GOVERNOR_ABI = [
  {
    type: 'function',
    name: 'propose',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'targets', type: 'address[]' },
      { name: 'values', type: 'uint256[]' },
      { name: 'calldatas', type: 'bytes[]' },
      { name: 'description', type: 'string' },
    ],
    outputs: [
      { name: 'proposalId', type: 'uint256' },
    ],
  },
] as const;

/**
 * Get configuration for on-chain proposal submission
 */
function getSubmissionConfig() {
  const CDP_API_KEY_ID = process.env.CDP_API_KEY_ID;
  const CDP_API_KEY_SECRET = process.env.CDP_API_KEY_SECRET;
  const DAO_GOVERNOR_ADDRESS = process.env.DAO_GOVERNOR_ADDRESS;
  const AGENT_SMART_ACCOUNT_ADDRESS = process.env.AGENT_SMART_ACCOUNT_ADDRESS;
  const AGENT_EOA_ADDRESS = process.env.AGENT_EOA_ADDRESS;

  if (!CDP_API_KEY_ID) {
    throw new Error('CDP_API_KEY_ID must be set in .env.local');
  }

  if (!CDP_API_KEY_SECRET) {
    throw new Error('CDP_API_KEY_SECRET must be set in .env.local');
  }

  if (!DAO_GOVERNOR_ADDRESS) {
    throw new Error('DAO_GOVERNOR_ADDRESS must be set in .env.local (Governor contract address on Zora)');
  }

  if (!AGENT_SMART_ACCOUNT_ADDRESS) {
    throw new Error('AGENT_SMART_ACCOUNT_ADDRESS must be set in .env.local (Smart Account to use as proposer)');
  }

  if (!AGENT_EOA_ADDRESS) {
    throw new Error('AGENT_EOA_ADDRESS must be set in .env.local (EOA that owns the Smart Account)');
  }

  return {
    CDP_API_KEY_ID,
    CDP_API_KEY_SECRET,
    DAO_GOVERNOR_ADDRESS: DAO_GOVERNOR_ADDRESS as Address,
    AGENT_SMART_ACCOUNT_ADDRESS: AGENT_SMART_ACCOUNT_ADDRESS as Address,
    AGENT_EOA_ADDRESS: AGENT_EOA_ADDRESS as Address,
  };
}

/**
 * Submit proposal to Builder DAO Governor on-chain (Zora network)
 * 
 * This function:
 * 1. Initializes CDP client with API credentials
 * 2. Encodes the propose() call with targets, values, calldatas, description
 * 3. Sends transaction via CDP Smart Account on Zora network
 * 4. Returns transaction hash and proposal ID (if available)
 * 
 * @param call - Governor proposal call parameters
 * @returns Transaction hash and optional proposal ID
 * 
 * @throws Error if environment variables are missing or transaction fails
 * 
 * @example
 * ```typescript
 * const proposal = await createBuyCoinProposal({ ... });
 * 
 * const result = await submitProposalToGovernor({
 *   targets: proposal.governorProposal.targets.map(t => t.toString()),
 *   values: proposal.governorProposal.values.map(v => v.toString()),
 *   calldatas: proposal.governorProposal.calldatas,
 *   description: proposal.governorProposal.description,
 * });
 * 
 * console.log(`Proposal submitted: ${result.txHash}`);
 * if (result.proposalId) {
 *   console.log(`On-chain proposal ID: ${result.proposalId}`);
 * }
 * ```
 */
export async function submitProposalToGovernor(
  call: GovernorProposalCall
): Promise<SubmitProposalResult> {
  console.log('üöÄ Submitting proposal to Governor on-chain...\n');
  
  // Step 1: Validate and get configuration
  const config = getSubmissionConfig();
  
  console.log('‚úÖ Configuration validated:');
  console.log(`   Governor Address: ${config.DAO_GOVERNOR_ADDRESS}`);
  console.log(`   Smart Account: ${config.AGENT_SMART_ACCOUNT_ADDRESS}`);
  console.log(`   Network: Zora`);
  console.log('');

  // Step 2: Initialize CDP client
  console.log('üîß Initializing CDP client...');
  const cdp = new CdpClient({
    apiKeyId: config.CDP_API_KEY_ID,
    apiKeySecret: config.CDP_API_KEY_SECRET,
    debugging: false,
  });
  console.log('‚úÖ CDP client initialized\n');

  try {
    // Step 3: Encode the propose() function call
    console.log('üìù Encoding propose() function call...');
    console.log(`   Targets: ${call.targets.length} contract(s)`);
    console.log(`   Values: ${call.values.length} value(s)`);
    console.log(`   Calldatas: ${call.calldatas.length} calldata(s)`);
    console.log(`   Description: ${call.description.split('\n')[0]}...`);
    
    const encodedData = encodeFunctionData({
      abi: GOVERNOR_ABI,
      functionName: 'propose',
      args: [
        call.targets as Address[],
        call.values.map(v => BigInt(v)),
        call.calldatas as Hex[],
        call.description,
      ],
    });
    
    console.log(`‚úÖ Encoded calldata: ${encodedData.slice(0, 66)}... (${encodedData.length} bytes)\n`);

    // Step 4: Load the Smart Account
    console.log('üîë Loading Smart Account...');
    
    // First, get the EOA owner
    const owner = await cdp.evm.getAccount({
      address: config.AGENT_EOA_ADDRESS,
    });
    
    console.log(`   ‚úÖ EOA owner loaded: ${owner.address}`);
    
    // Then get the Smart Account with the owner
    const smartAccount = await cdp.evm.getSmartAccount({
      address: config.AGENT_SMART_ACCOUNT_ADDRESS,
      owner: owner,
    });
    
    console.log(`   ‚úÖ Smart Account loaded: ${smartAccount.address}\n`);

    // Step 5: Send user operation to Governor contract
    console.log('üì§ Sending user operation to Governor...');
    console.log(`   Governor: ${config.DAO_GOVERNOR_ADDRESS}`);
    console.log(`   Calldata: ${encodedData.slice(0, 66)}...`);
    console.log(`   Network: base`);
    
    const userOpResult = await cdp.evm.sendUserOperation({
      smartAccount,
      network: 'base',
      calls: [{
        to: config.DAO_GOVERNOR_ADDRESS,
        data: encodedData,
        value: BigInt(0),
      }],
    });
    
    console.log(`   ‚úÖ User operation submitted!`);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const userOpHash = (userOpResult as any).userOpHash || (userOpResult as any).hash || (userOpResult as any).userOperationHash;
    console.log(`   User Op Hash: ${userOpHash}`);
    console.log('');

    // Step 6: Wait for user operation to be included in a block
    console.log('‚è≥ Waiting for user operation to be included in a block...');
    console.log('   (This may take 10-30 seconds on testnet)\n');

    const receipt = await cdp.evm.waitForUserOperation({
      smartAccountAddress: smartAccount.address,
      userOpHash,
    });

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const txHash = (receipt as any).transactionHash || (receipt as any).hash;
    console.log(`   ‚úÖ Included in block!`);

    // Step 7: Parse ProposalCreated event from receipt
    // TODO: Parse the proposalId from ProposalCreated event
    // The ProposalCreated event has this signature:
    // event ProposalCreated(
    //   uint256 indexed proposalId,
    //   address indexed proposer,
    //   address[] targets,
    //   uint256[] values,
    //   string[] signatures,
    //   bytes[] calldatas,
    //   string description
    // );
    //
    // To parse:
    // const proposalCreatedTopic = keccak256('ProposalCreated(...)')
    // const receipt = await provider.getTransactionReceipt(txHash)
    // const log = receipt.logs.find(log => log.topics[0] === proposalCreatedTopic)
    // const proposalId = BigInt(log.topics[1]).toString() // First indexed param
    
    console.log('‚úÖ Proposal submitted successfully!');
    console.log(`   Transaction Hash: ${txHash}`);
    console.log(`   View on explorer: https://sepolia.basescan.org/tx/${txHash}\n`);

    return {
      txHash: txHash,
      proposalId: undefined, // TODO: Parse from ProposalCreated event
    };
  } catch (error) {
    console.error('\n‚ùå Error submitting proposal:');
    
    if (error instanceof Error) {
      console.error(`   Message: ${error.message}`);
      if (error.stack) {
        console.error(`   Stack: ${error.stack}`);
      }
    } else {
      console.error(`   ${JSON.stringify(error, null, 2)}`);
    }
    
    throw error;
  }
}

/**
 * Helper: Submit a BuyCoinProposal on-chain
 * Converts BuyCoinProposal to GovernorProposalCall and submits
 */
export async function submitBuyCoinProposal(
  proposal: BuyCoinProposal
): Promise<SubmitProposalResult> {
  const call: GovernorProposalCall = {
    targets: proposal.governorProposal.targets.map(t => t.toString()),
    values: proposal.governorProposal.values.map(v => v.toString()),
    calldatas: proposal.governorProposal.calldatas,
    description: proposal.governorProposal.description,
  };

  return submitProposalToGovernor(call);
}
